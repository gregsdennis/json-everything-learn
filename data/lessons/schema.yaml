---
- id: 26b6ebca-58e6-4814-86ea-4946d844c9a8
  background: |
    JSON Schema is typically itself represented in JSON.  To support this, the `JsonSchema`
    type is completely compatible with the _System.Text.Json_ serializer.
  docs: 'schema/basics/#schema-deserialization'
  title: Deserializing a Schema
  instructions: |
    Deserialize the text in `schemaText` into a `JsonSchema` variable called `schema`.
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json;
    using System.Text.Json.Nodes;
    using Json.Schema;
    
    namespace LearnJsonEverything;
    
    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var schemaText =
                """
                {
                  "type": "object",
                  "properties": {
                    "foo": { "type": "number", "minimum": 0 },
                    "bar": { "type": "string" }
                  },
                  "required": ["foo", "bar"]
                }
                """;

            /* USER CODE */

            return schema.Evaluate(instance);
        }
    }
  solution: |-
    var schema = JsonSerializer.Deserialize<JsonSchema>(schemaText);
  tests:
  - instance: { "foo": 13, "bar": "a string" }
    isValid: true
  - instance: { "foo": false, "bar": "a string" }
    isValid: false
  - instance: { "foo": 13 }
    isValid: false
  - instance: { "bar": "a string" }
    isValid: false
  - instance: [1,2,3]
    isValid: false
  - instance: 6.8
    isValid: false
- id: 26b6ebca-58e6-4824-86ea-4946d844c9a8
  skip: true  # source gen is not available in dynamic compilation
  background: |
    JSON Schema is typically itself represented in JSON.  To support this, the `JsonSchema`
    type is completely compatible with the _System.Text.Json_ serializer.

    When compiling a Native AOT application or when trimming assemblies, you'll need to add
    `JsonSchema` and `EvaluationOptions` to your serializer context in order to support
    source generation.
  docs: 'schema/basics/#aot'
  title: Deserializing a Schema (AOT)
  instructions: |
    Create a serializer context class called `MySerializerContext` and add the appropriate
    attributes.
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json;
    using System.Text.Json.Nodes;
    using System.Text.Json.Serialization;
    using Json.Schema;
    
    namespace LearnJsonEverything;
    
    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var schemaText =
                """
                {
                  "type": "object",
                  "properties": {
                    "foo": { "type": "number", "minimum": 0 },
                    "bar": { "type": "string" }
                  },
                  "required": ["foo", "bar"]
                }
                """;

            JsonSerializer.Deserialize(schemaText, MySerializerContext.Default.JsonSchema);

            return schema.Evaluate(instance);
        }
    }

    /* USER CODE */
  solution: |-
    [JsonSerializable(typeof(JsonSchema))]
    [JsonSerializable(typeof(EvaluationResults))]
    internal partial class MySerializerContext : JsonSerializerContext;
  tests:
  - instance: { "foo": 13, "bar": "a string" }
    isValid: true
  - instance: { "foo": false, "bar": "a string" }
    isValid: false
  - instance: { "foo": 13 }
    isValid: false
  - instance: { "bar": "a string" }
    isValid: false
  - instance: [1,2,3]
    isValid: false
  - instance: 6.8
    isValid: false
- id: 26b6ebca-58e6-4814-86ea-4946d844c9a6
  title: 'Schema Builder: Any String'
  background: |
    The `JsonSchemaBuilder` class provides a type-safe fluent interface for building schemas in code.
    Adding a keyword is accomplished by calling the same-name (usually) extension method.
  docs: 'schema/basics/#schema-inlining'
  api: api/JsonSchema.Net/JsonSchemaBuilderExtensions
  instructions: |
    Configure the provided `JsonSchemaBuilder` to produce a schema that validates a string instance.
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json.Nodes;
    using Json.Schema;
    
    namespace LearnJsonEverything;
    
    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var builder = new JsonSchemaBuilder();

            /* USER CODE */

            var schema = builder.Build();
            return schema.Evaluate(instance);
        }
    }
  solution: |-
    builder.Type(SchemaValueType.String);
  tests:
  - instance: a string value
    isValid: true
  - instance: []
    isValid: false
  - instance: 42
    isValid: false
  - instance: false
    isValid: false
- id: 26b6ebca-58e6-4814-86ea-4946d844c9a7
  title: 'Schema Builder: Number with Limits'
  background: |
    The `JsonSchemaBuilder` class provides a type-safe fluent interface for building schemas in code.
    Adding a keyword is accomplished by calling the same-name (usually) extension method.
  docs: 'schema/basics/#schema-inlining'
  api: api/JsonSchema.Net/JsonSchemaBuilderExtensions
  instructions: |
    Configure the provided `JsonSchemaBuilder` to produce a schema that validates a number instance
    that is less than or equal to 10 but greater than 0.
  inputTemplate: ''
  contextCode: |-
    using System.Collections.Generic;
    using System.Text.Json.Nodes;
    using Json.Schema;
    
    namespace LearnJsonEverything;
    
    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var builder = new JsonSchemaBuilder();

            /* USER CODE */

            var schema = builder.Build();
            return schema.Evaluate(instance);
        }
    }
  solution: |-
    builder.Type(SchemaValueType.Number)
        .ExclusiveMinimum(0)
        .Maximum(10);
  tests:
  - instance: 6.8
    isValid: true
  - instance: 10
    isValid: true
  - instance: 42e-6
    isValid: true
  - instance: -5.1
    isValid: false
  - instance: 0
    isValid: false
  - instance: a string value
    isValid: false
  - instance: []
    isValid: false
  - instance: {}
    isValid: false
  - instance: false
    isValid: false
- id: 36b6ebca-58e6-4814-86ea-4946d844c9a7
  background: |
    The `JsonSchemaBuilder` class provides a type-safe fluent interface for building schemas in code.
    Adding a keyword is accomplished by calling the same-name (usually) extension method.

    Some keywords take schemas.  To do this with _JsonSchema.Net_, you'll want to pass a nested
    `JsonSchemaBuilder` into the `.Items()` extension method.

    To help make your code prettier, there is an implicit cast from `JsonSchemaBuilder` to `JsonSchema`
    that automatically calls the `.Build()` method so you don't have to.
  docs: 'schema/basics/#schema-inlining'
  api: api/JsonSchema.Net/JsonSchemaBuilderExtensions
  title: 'Schema Builder: Nesting Schemas'
  instructions: |
    Configure the provided `JsonSchemaBuilder` to produce a schema that validates a array instance
    filled with integers.  Ensure that the array has no more than 5 items.
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json.Nodes;
    using Json.Schema;
    
    namespace LearnJsonEverything;
    
    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var builder = new JsonSchemaBuilder();

            /* USER CODE */

            var schema = builder.Build();
            return schema.Evaluate(instance);
        }
    }
  solution: |-
    builder.Type(SchemaValueType.Array)
        .Items(new JsonSchemaBuilder().Type(SchemaValueType.Integer))
        .MaxItems(5);
  tests:
  - instance: 6.8
    isValid: false
  - instance: [1,2,3]
    isValid: true
  - instance: ["string",1,2]
    isValid: false
  - instance: [1,2,3,4,5,6]
    isValid: false
  - instance: a string value
    isValid: false
  - instance: []
    isValid: true
  - instance: {}
    isValid: false
  - instance: false
    isValid: false
- id: 26b6ebca-58e6-4814-86ea-4946d444c9a8
  background: |
    By default, JSON Schema doesn't validate the `format` keyword.  Instead, tools
    are generally encouraged to provide a configuration option to enforce `format` validation.

    In _JsonSchema.Net_ that option is called `RequiredFormatValidation`.
  docs: 'schema/basics/#schema-format'
  title: 'Options: Validating Formats'
  instructions: |
    Configure the evaluation options to enable `format` validation.
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json.Nodes;
    using Json.Schema;
    
    namespace LearnJsonEverything;
    
    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var format = test["format"].GetValue<string>();
            JsonSchema schema = new JsonSchemaBuilder()
                .Type(SchemaValueType.String)
                .Format(format); 

            var options = new EvaluationOptions();

            /* USER CODE */

            return schema.Evaluate(instance, options);
        }
    }
  solution: |-
    options.RequireFormatValidation = true;
  tests:
  - instance: 2015-06-13T10:31:16+04:00
    format: date-time
    isValid: true
  - instance: 2015-06-13
    format: date-time
    isValid: false
  - instance: 1.1.1.1
    format: ipv4
    isValid: true
  - instance: www.google.com
    format: ipv4
    isValid: false
  - instance: '/json/pointer'
    format: json-pointer
    isValid: true
  - instance: '/inva~lid/pointer'
    format: json-pointer
    isValid: false
  # - instance: '0/json/pointer'
  #   format: relative-json-pointer
  #   isValid: true
  - instance: {}
    format: date-time
    isValid: false
  - instance: []
    format: date-time
    isValid: false
  - instance: 6.8
    format: date-time
    isValid: false
- id: 26b6ebca-58e6-4814-8dea-4946d444c9a8
  background: |
    _JsonSchema.Net_ supports every version of JSON Schema from Draft 6 forward.

    Version selection can be key to figuring out how to evaluate a schema.  Generally,
    the version will be determined by the meta-schema, as declared by the `$schema`
    keyword.  However, when `$schema` is absent, it's up to the tool and user to
    decide.

    To set the JSON Schema version to use, you'll need to set the `EvaluateAs` property
    on the evaluation options.

    This setting will have no effect if the schema _does_ have `$schema`.

    Lastly, this property is init-only, so you'll need to set it when creating the 
    options object.

    \* _This lesson works by taking advantage of the fact that JSON Schema ignores unknown
    keywords.  So when it evaluates a schema as Draft 6 that contains keywords from
    Draft 7, the Draft 7 keywords aren't processed._
  docs: 'schema/basics/#schema-options'
  title: 'Options: JSON Schema Version'
  instructions: |
    Create and configure an evaluation options object, and set the JSON Schema version
    found in the `specVersion` variable.
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json;
    using System.Text.Json.Nodes;
    using Json.Schema;
    using Json.More;
    
    namespace LearnJsonEverything;
    
    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var specVersion = test["version"].Deserialize<SpecVersion>(
                new JsonSerializerOptions
                {
                    Converters = { new EnumStringConverter<SpecVersion>() }
                }
            );

            JsonSchema schema = new JsonSchemaBuilder()
                .Type(SchemaValueType.Array)
                .Items(new JsonSchemaBuilder()
                    .Type(SchemaValueType.Integer)
                )
                .Contains(new JsonSchemaBuilder().Const(4))
                // Introduced with Draft 7
                .If(new JsonSchemaBuilder().MinItems(3))
                .Then(new JsonSchemaBuilder()
                    .Items(new JsonSchemaBuilder().MultipleOf(2))
                )
                // Introduced with Draft 2019-09
                .MinContains(2)
                // Introduced with Draft 2020-12
                .PrefixItems(
                    new JsonSchemaBuilder().Type(SchemaValueType.String),
                    new JsonSchemaBuilder().Type(SchemaValueType.Boolean)
                );

            /* USER CODE */

            return schema.Evaluate(instance, options);
        }
    }
  solution: |-
    var options = new EvaluationOptions { EvaluateAs = specVersion };
  tests:
  - instance: [{},4]
    version: Draft6
    isValid: false
  - instance: [2,3,4,5]
    version: Draft6
    isValid: true
  - instance: [2,3,4,5]
    version: Draft7
    isValid: false
  - instance: [2,4,6,8]
    version: Draft7
    isValid: true
  - instance: [2,4,6,8]
    version: Draft201909
    isValid: false
  - instance: [2,4,6,8,4]
    version: Draft201909
    isValid: true
  - instance: [2,4,6,8,4]
    version: Draft202012
    isValid: false
  - instance: ["a string",true,2,4,6,8,4]
    version: Draft202012
    isValid: true
- id: 26b6ebca-58e6-4824-8dea-4946d444c9a8
  background: |
    Most often you need to ensure that incoming JSON data properly represents the models
    you've created for your application.  Often the best way to ensure this is to
    generate schemas directly from those models.

    _JsonSchema.Net.Generation_ provides an additional extension on `JsonSchemaBuilder`
    called `.FromType<T>()`.
  docs: 'schema/schemagen/schema-generation'
  title: 'Generation: Essentials'
  instructions: |
    Configure the builder to generate a schema for the `Person` type.
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json.Nodes;
    using Json.Schema;
    using Json.Schema.Generation;
    
    namespace LearnJsonEverything;
    
    public class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public int Age { get; set; }
    }

    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var builder = new JsonSchemaBuilder();

            /* USER CODE */

            var schema = builder.Build();
            return schema.Evaluate(instance);
        }
    }
  solution: |-
    builder.FromType<Person>();
  tests:
  - instance: { FirstName: Jane, LastName: Doe, Age: 24 }
    isValid: true
  - instance: { FirstName: Jane }
    isValid: true
  - instance: { FirstName: 24 }
    isValid: false
- id: 26b6ebca-5de6-4824-8dea-4946d444c9a8
  background: |
    Most often you need to ensure that incoming JSON data properly represents the models
    you've created for your application.  Often the best way to ensure this is to
    generate schemas directly from those models.

    _JsonSchema.Net.Generation_ provides an additional extension on `JsonSchemaBuilder`
    called `.FromType<T>()`.  It also provides numerous attributes that can be applied
    to your models in order to create additional constraints in the generated schema.
  docs: 'schema/schemagen/schema-generation#schema-schemagen-best-practices'
  title: 'Generation: More Constraints'
  instructions: |
    Add `FirstName`, `LastName`, and `Age` properties to the `Person` class, and add
    attributes that provide the following constraints:

    - all properties are required
    - `FirstName` and `LastName` must be at least two characters long
    - `Age` must be greater than 0
  inputTemplate: ''
  contextCode: |-
    using System.Text.Json.Nodes;
    using Json.Schema;
    using Json.Schema.Generation;
    
    namespace LearnJsonEverything;
    
    public class Person
    {
        /* USER CODE */
    }

    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var builder = new JsonSchemaBuilder().FromType<Person>();
            var schema = builder.Build();
            return schema.Evaluate(instance);
        }
    }
  solution: |-
    [Required]
    [MinLength(2)]
    public string FirstName { get; set; }
    [Required]
    [MinLength(2)]
    public string LastName { get; set; }
    [Required]
    [ExclusiveMinimum(0)]
    public int Age { get; set; }
  tests:
  - instance: { FirstName: Jane, LastName: Doe, Age: 24 }
    isValid: true
  - instance: { FirstName: Jane, LastName: Doe }
    isValid: false
  - instance: { FirstName: Jane, Age: 24 }
    isValid: false
  - instance: { LastName: Doe, Age: 24 }
    isValid: false
  - instance: { FirstName: 24 }
    isValid: false
  - instance: { FirstName: J, LastName: Doe, Age: 24 }
    isValid: false
  - instance: { FirstName: Jane, LastName: D, Age: 24 }
    isValid: false
  - instance: { FirstName: Jane, LastName: Doe, Age: -6 }
    isValid: false
- id: 26b6ebca-5de6-4824-8dea-4a46d444c9a8
  background: |
    Most often you need to ensure that incoming JSON data properly represents the models
    you've created for your application.  Often the best way to ensure this is to
    generate schemas directly from those models.

    _JsonSchema.Net.Generation_ provides an additional extension on `JsonSchemaBuilder`
    called `.FromType<T>()`.  It also provides numerous attributes that can be applied
    to your models in order to create additional constraints in the generated schema.

    Nullability works differently in JSON and JSON Schema than it does in .Net.  Use
    the `[Nullable()]` attribute to support null values the JSON / JSON Schema way.
  docs: 'schema/schemagen/schema-generation#schema-schemagen-nullability'
  title: 'Generation: Nullability'
  instructions: |
    Add a `DateTime` property called `BirthDate` and mark it as nullable.
  inputTemplate: ''
  contextCode: |-
    using System;
    using System.Text.Json.Nodes;
    using Json.Schema;
    using Json.Schema.Generation;
    
    namespace LearnJsonEverything;
    
    public class Person
    {
        [Required]
        [MinLength(2)]
        public string FirstName { get; set; }
        [Required]
        [MinLength(2)]
        public string LastName { get; set; }
        [Required]
        [ExclusiveMinimum(0)]
        public int Age { get; set; }

        /* USER CODE */
    }

    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var instance = test["instance"];
            var builder = new JsonSchemaBuilder().FromType<Person>();
            var schema = builder.Build();
            // DateTime will generate a `format: date-time` constraint,
            // so we need to be sure to validate the `format` keyword.
            var options = new EvaluationOptions { RequireFormatValidation = true };
            return schema.Evaluate(instance, options);
        }
    }
  solution: |-
    [Nullable(true)]
    public DateTime? BirthDate { get; set; }
  tests:
  - instance: { FirstName: Jane, LastName: Doe, Age: 24 }
    isValid: true
  - instance: { FirstName: Jane, LastName: Doe, Age: 24, BirthDate: null }
    isValid: true
  - instance: { FirstName: Jane, LastName: Doe, Age: 24, BirthDate: '2000-06-13T00:00:00-06:00' }
    isValid: true
  - instance: { FirstName: Jane, LastName: Doe, Age: 24, BirthDate: '13 June 2000' }
    isValid: false
  - instance: { FirstName: Jane, LastName: Doe, Age: 24, BirthDate: 24 }
    isValid: false
- id: 26b6ebca-5de6-4824-8dea-4a46d414c9a8
  background: |
    Most often you need to ensure that incoming JSON data properly represents the models
    you've created for your application.  Often the best way to ensure this is to
    generate schemas directly from those models.

    _JsonSchema.Net.Generation_ provides an additional extension on `JsonSchemaBuilder`
    called `.FromType<T>()`.

    Generation will also look for the `<summary>` tag in XML comments to add a `description`
    keyword to your schemas.  This is supported on properties and types.
  docs: 'schema/schemagen/schema-generation#schema-schemagen-nullability'
  title: 'Generation: XML Comments'
  instructions: |
    Add some XML comments to the `Person` type to generate a `description` keyword.
  inputTemplate: ''
  contextCode: |-
    using System;
    using System.Text.Json;
    using System.Text.Json.Nodes;
    using Json.Schema;
    using Json.Schema.Generation;
    using Json.More;
    
    namespace LearnJsonEverything;
    
    /* USER CODE */
    public class Person
    {
        [Required]
        [MinLength(2)]
        public string FirstName { get; set; }
        [Required]
        [MinLength(2)]
        public string LastName { get; set; }
        [Required]
        [ExclusiveMinimum(0)]
        public int Age { get; set; }
    }

    public class Lesson : ILessonRunner<EvaluationResults>
    {
        public EvaluationResults Run(JsonObject test)
        {
            var builder = new JsonSchemaBuilder().FromType<Person>();
            var schema = builder.Build();
            var schemaAsNode = JsonSerializer.SerializeToNode(schema);
            
            var metaSchema = new JsonSchemaBuilder()
              .Type(SchemaValueType.Object)
              .Required("description");

            return metaSchema.Evaluate(schemaAsNode);
        }
    }
  solution: |-
    /// <summary>
    /// This is my summary.  It'll end up in a `description` keyword.
    /// </summary>
  tests:
  - instance: null
    isValid: true
