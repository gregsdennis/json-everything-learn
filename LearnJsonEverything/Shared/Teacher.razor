@using BlazorMonaco.Editor
@using Json.Schema
@using LearnJsonEverything.Services
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using System.Reflection
@using System.Text.Json

@inject DataManager DataManager;
@inject NavigationManager NavigationManager;
@inject IJSRuntime JsRuntime;
@inject HttpClient Client;

<div id="layout" class="row fill-remaining row-margin-reset">
	<div class="col-4 d-flex">
		<div class="grid-panel flex-grow-1">
			content
		</div>
	</div>
	<div class="col-8 d-flex">
		<div id="right-panel" class="row row-margin-reset flex-grow-1">
			<div id="workspace" class="col-12 d-flex flex-grow-1">
				<div class="grid-panel flex-grow-1">
					content
				</div>
			</div>
			<div id="controls" class="col-12">
				<div class="d-flex">
					<div class="btn btn-primary m-1">
						content
					</div>
					<div class="btn btn-primary m-1">
						content
					</div>
					<div class="btn btn-primary m-1">
						content
					</div>
				</div>
			</div>
			<div id="output" class="col-12 d-flex">
				<div class="grid-panel flex-grow-1">
					content
				</div>
			</div>
		</div>
	</div>
</div>

@code {
	private StandaloneCodeEditor _codeEditor;
	private StandaloneCodeEditor _outputEditor;
	private List<MetadataReference> _references;
	private LessonPlan _lessons;
	private LessonData? _currentLesson;

	[Parameter]
	public string LessonSource { get; set; }

	private string Output { get; set; }
	private bool Success { get; set; }

	private async Task TryRun()
	{
		Assembly? assembly = null;
		try
		{
			var source = await _codeEditor.GetValue();

			var fullSource = $@"
using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using Json.Schema;
using Json.Schema.Generation;

namespace JsonEverythingTemp;

{source}
";

			var syntaxTree = CSharpSyntaxTree.ParseText(fullSource);
			var assemblyPath = Path.ChangeExtension(Path.GetTempFileName(), "dll");

			var compilation = CSharpCompilation.Create(Path.GetFileName(assemblyPath))
				.WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
				.AddReferences(_references)
				.AddSyntaxTrees(syntaxTree);

			using var dllStream = new MemoryStream();
			using var pdbStream = new MemoryStream();
			using var xmlStream = new MemoryStream();
			var emitResult = compilation.Emit(dllStream, pdbStream, xmlStream);
			if (!emitResult.Success)
			{
				Console.WriteLine("You may expect a list of what compilation errors there are, but unfortunately " +
										"Roslyn doesn't seem to be giving that information out (or I don't know how to " +
										"interpret it).  So instead, here are the errors in raw form.  Good luck.  If you " +
										"know what these mean, please drop a line in a GitHub issue.");
				await _outputEditor.SetValue("Compilation error");
				//var errors = string.Join("\n", emitResult.Diagnostics.Where(x => x.Severity == DiagnosticSeverity.Error)
				//	.Select(x => GetErrorDetails(source, x)));
				//await _outputEditor.SetValue(errors);
				return;
			}

			assembly = Assembly.Load(dllStream.ToArray());

			// run the code
		}
		catch (Exception e)
		{
			await _outputEditor.SetLanguageAsync("text", JsRuntime);
			await _outputEditor.SetValue(e.Message);
		}
	}

	private Task NextLesson()
	{
		_currentLesson = _lessons.GetNext(_currentLesson?.Id);
		return LoadLesson();
	}

	private Task PreviousLesson()
	{
		_currentLesson = _lessons.GetNext(_currentLesson?.Id);
		return LoadLesson();
	}

	private Task Reset()
	{
		return LoadLesson();
	}

	private async Task LoadLesson()
	{
		
	}

	protected override async Task OnInitializedAsync()
	{
		// await Configure();
		// await LoadAssemblyReferences();
		await DownloadLessonPlan();
		
		await LoadLesson();

		await base.OnInitializedAsync();
	}

	private async Task Configure()
	{
		await _codeEditor.SetLanguageAsync("csharp", JsRuntime);
		await _codeEditor.UpdateOptions(new EditorUpdateOptions { TabSize = 4 });
		await DataManager.Set("schema-input-language", "csharp");
	}

	private async Task LoadAssemblyReferences()
	{
		var refs = AppDomain.CurrentDomain.GetAssemblies();

		var references = new List<MetadataReference>();

		foreach (var reference in refs.Where(x => !x.IsDynamic))
		{
			Console.WriteLine($"{reference.FullName}\n  Location - {reference.Location}\n");
		}

		foreach (var reference in refs.Where(x => !x.IsDynamic))
		{
			var stream = await Client.GetStreamAsync($"_framework/{reference.FullName!.Split(',')[0]}.dll");
			references.Add(MetadataReference.CreateFromStream(stream));
		}

		_references = references;
	}

	private async Task DownloadLessonPlan()
	{
		_lessons = await Client.GetFromJsonAsync<LessonPlan>(LessonSource);
	}
}
